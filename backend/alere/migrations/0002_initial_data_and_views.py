# Generated by Django 3.0.7 on 2020-10-05 19:50

from django.db import migrations     # type: ignore
import django.db                     # type: ignore
from alere import models
import sys


armageddon = "'2999-12-31 00:00:00'"


def create_views(apps, schema_editor):
    models.Scenarios.objects.create(
        id=models.Scenarios.NO_SCENARIO,
        name='Actual transactions',
    )

    models.PriceSources.objects.create(
        id=models.PriceSources.USER,
        name="User",
    )
    models.PriceSources.objects.create(
        id=models.PriceSources.YAHOO,
        name="Yahoo Finance",
    )
    models.PriceSources.objects.create(
        id=models.PriceSources.TRANSACTION,
        name="Transaction",
    )

    PASSIVE_INCOME = models.AccountKinds.objects.create(
        name="Passive income",
        name_when_positive='Expense',
        name_when_negative='Income',
        category=models.AccountKindCategory.INCOME,
        is_passive_income=True,
    )

    WORK_INCOME = models.AccountKinds.objects.create(
        name="Work income",
        name_when_positive='Expense',
        name_when_negative='Income',
        category=models.AccountKindCategory.INCOME,
        is_work_income=True,
    )

    MISC_INCOME = models.AccountKinds.objects.create(
        name="Misc income",
        name_when_positive='Expense',
        name_when_negative='Income',
        category=models.AccountKindCategory.INCOME,
        is_work_income=False,
    )

    UNREALIZED_GAINS = models.AccountKinds.objects.create(
        name="Unrealized gain",
        name_when_positive='Decrease',
        name_when_negative='Increase',
        category=models.AccountKindCategory.INCOME,
        is_unrealized=True,
    )

    EXPENSE = models.AccountKinds.objects.create(
        name="Expense",
        name_when_positive='Expense',
        name_when_negative='Income',
        category=models.AccountKindCategory.EXPENSE,
    )

    INCOME_TAX = models.AccountKinds.objects.create(
        name="Income tax",
        name_when_positive='Increase',
        name_when_negative='Decrease',
        category=models.AccountKindCategory.EXPENSE,
        is_income_tax=True,
    )

    MISC_TAX = models.AccountKinds.objects.create(
        name="Other tax",
        name_when_positive='Increase',
        name_when_negative='Decrease',
        category=models.AccountKindCategory.EXPENSE,
        is_misc_tax=True,
    )

    LIABILITY = models.AccountKinds.objects.create(
        name="Liability",
        name_when_positive='Deposit',
        name_when_negative='Paiement',
        category=models.AccountKindCategory.LIABILITY,
        is_networth=True,
    )

    STOCK = models.AccountKinds.objects.create(
        name="Stock",
        name_when_positive='Add',
        name_when_negative='Remove',
        category=models.AccountKindCategory.EQUITY,
        is_trading=True,
        is_stock=True,
        is_networth=True,
    )

    BANK = models.AccountKinds.objects.create(
        name="Bank account",
        name_when_positive='Deposit',
        name_when_negative='Paiement',
        category=models.AccountKindCategory.EQUITY,
        is_networth=True,
    )

    EQUITY = models.AccountKinds.objects.create(
        name="Equity",
        name_when_positive='Increase',
        name_when_negative='Decrease',
        category=models.AccountKindCategory.EQUITY,
        is_networth=False,
    )

    INVESTMENT = models.AccountKinds.objects.create(
        name="Investment",
        name_when_positive='Deposit',
        name_when_negative='Paiement',
        category=models.AccountKindCategory.EQUITY,
        is_networth=True,
        is_trading=True,
    )

    ASSET = models.AccountKinds.objects.create(
        name="Asset",
        name_when_positive='Increase',
        name_when_negative='Decrease',
        category=models.AccountKindCategory.ASSET,
        is_networth=True,
    )

    NON_LIQUID_INVESTMENT = models.AccountKinds.objects.create(
        name="Non-liquid Investment",
        name_when_positive='Deposit',
        name_when_negative='Paiement',
        category=models.AccountKindCategory.ASSET,
        is_networth=True,
        is_trading=True,
    )


class Migration(migrations.Migration):

    dependencies = [
        ('alere', '0001_initial'),
    ]

    operations = [
        migrations.RunPython(create_views),
        migrations.RunSQL(
        f"""

        --  Lookup prices in various places.
        --  This combines price information from the historical prices in
        --  alr_prices (applying conversions in both directions), and from
        --  the prices used in actual transactions.
        --  This table only has currencies as targets, so can contain the
        --  price of stocks or exchange rates between currencies.
        --  Only prices explicitly found in the database exist.
        --
        --  scaled_price are scaled by origin's price_scale as in alr_prices

        DROP VIEW IF EXISTS alr_raw_prices;
        CREATE VIEW alr_raw_prices AS
           SELECT origin_id, target_id, scaled_price, date, source_id
              FROM alr_prices p2
                 JOIN alr_commodities t ON (p2.target_id=t.id)
              WHERE t.kind = '{models.CommodityKinds.CURRENCY}'

           UNION ALL

           --  consider exchange rates in both directions
           SELECT target_id, origin_id,
               CAST(target.price_scale AS FLOAT)
                  * origin.price_scale
                  / alr_prices.scaled_price,
               date,
               source_id
              FROM alr_prices
                 JOIN alr_commodities origin
                    ON (alr_prices.origin_id=origin.id)
                 JOIN alr_commodities target
                    ON (alr_prices.target_id=target.id)
              WHERE origin.kind='{models.CommodityKinds.CURRENCY}'

           UNION ALL

           --  extract prices from transactions.
           SELECT a.commodity_id AS origin_id,
              s.value_commodity_id AS target_id,
              CAST(s.scaled_value
                   * a.commodity_scu    --  scale for s.scaled_qty
                   * curr.price_scale   --  to get a scaled value
                   AS FLOAT)
                 / (s.scaled_qty
                    * t.price_scale     --  scale for s.scaled_value
                ),
              s.post_date AS date,
              {models.PriceSources.TRANSACTION} as source_id
              FROM alr_splits s
                 JOIN alr_commodities t ON (s.value_commodity_id=t.id)
                 JOIN alr_accounts a ON (s.account_id=a.id)
                 JOIN alr_commodities curr ON (a.commodity_id=curr.id)
              WHERE t.kind='{models.CommodityKinds.CURRENCY}'
                 AND a.commodity_id <> s.value_commodity_id

           UNION ALL

           --  extract prices from transactions
           SELECT s.value_commodity_id AS origin_id,
              a.commodity_id AS target_id,
              CAST(s.scaled_qty
                   * t.price_scale   --  scale for s.scaled_value
                   * t.price_scale   --  to get a scaled value
                   AS FLOAT)
                  / (s.scaled_value
                     * a.commodity_scu    --  scale for s.scaled_qty
                    ),
              s.post_date AS date,
              {models.PriceSources.TRANSACTION} as source_id
              FROM alr_splits s
                 JOIN alr_commodities t ON (s.value_commodity_id=t.id)
                 JOIN alr_accounts a ON (s.account_id=a.id)
                 JOIN alr_commodities curr ON (a.commodity_id=curr.id)
              WHERE curr.kind='{models.CommodityKinds.CURRENCY}'
                 AND a.commodity_id <> s.value_commodity_id

           UNION ALL

           --  A currency always has a 1.0 exchange rate with itself. This
           --  simplifies the computation of balances later on
           SELECT c.id AS origin_id,
              c.id AS target_id,
              c.price_scale AS scaled_price,
              '1900-01-01 00:00:00' as date,
              {models.PriceSources.TRANSACTION} as source_id
              FROM alr_commodities c
              WHERE c.kind='{models.CommodityKinds.CURRENCY}'
        ;

        --  Similar to alr_raw_prices but also include prices after going
        --  through a turnkey currency (ie commodity -> currency1 -> currency2)
        --  by taking advantage of the exchange rates in the database. Because
        --  there is always a 1.0 xrate from a currency to itself, all the
        --  direct commodity->currency1 rates are also available.
        --  All prices scaled by origin.price_scale
        DROP VIEW IF EXISTS alr_raw_prices_with_turnkey;
        CREATE VIEW alr_raw_prices_with_turnkey AS
           SELECT a.origin_id,
               p.target_id,
               CAST(a.scaled_price AS FLOAT) * p.scaled_price
               / c.price_scale AS scaled_price,  --  in p.target_id
               o.price_scale,
               a.date,
               a.source_id
           FROM alr_raw_prices a
                JOIN alr_commodities o ON (a.origin_id=o.id)
                JOIN alr_price_history p ON (a.target_id=p.origin_id)
                JOIN alr_commodities c ON (p.origin_id=c.id)
           WHERE
             p.mindate<=a.date
             AND a.date<p.maxdate

             --  A currency always has an xrate 1<->1 with itself
             AND (a.origin_id != p.target_id
                  OR a.origin_id = a.target_id)
        ;

        --  Provide price of commodities for any point in time.
        DROP VIEW IF EXISTS alr_price_history;
        CREATE VIEW alr_price_history AS
           SELECT p.origin_id,   --  Currency or Stock
             p.target_id,        --  Always a currency
             p.scaled_price,     --  scaled by origin_id's price_scale
             p.date as mindate,
             COALESCE(
                LEAD(p.date)
                   OVER (PARTITION BY p.origin_id, p.target_id
                         ORDER BY p.date),
                {armageddon}
             ) as maxdate,
             p.source_id
           FROM alr_raw_prices p
        ;

        DROP VIEW IF EXISTS alr_price_history_with_turnkey;
        CREATE VIEW alr_price_history_with_turnkey AS
           SELECT p.origin_id,
             p.target_id,
             p.scaled_price,
             p.price_scale,
             p.date as mindate,
             COALESCE(
                LEAD(p.date)
                   OVER (PARTITION BY p.origin_id, p.target_id
                         ORDER BY p.date),
                {armageddon}
             ) as maxdate,
             p.source_id
           FROM alr_raw_prices_with_turnkey p
        ;

        --------------------
        --  Compute the balance of accounts at a certain date.
        --  Those balances are computed for all scenarios (so filtering will
        --  be needed, which also improves the performance), and whether or
        --  not to include scheduled transactions and their recurrences.
        --------------------

        DROP VIEW IF EXISTS alr_balances;
        CREATE VIEW alr_balances AS
           WITH RECURSIVE scenarios AS (
              SELECT id FROM alr_scenarios

           ), scheduled(include) AS (
              SELECT *
              FROM (VALUES (1), (0)) foo

           ), recurring_splits_and_transaction AS (
              --  overrides the post_date for the splits associated with a
              --  recurring transaction
              SELECT
                 t.timestamp,
                 t.scheduled,
                 t.scenario_id,
                 s.account_id,
                 s.scaled_qty,
                 alr_next_event(t.scheduled, t.timestamp, t.last_occurrence) as post_date
              FROM alr_transactions t
                 JOIN alr_splits s ON (s.transaction_id = t.id)
              WHERE t.scheduled IS NOT NULL

              --  and compute the later occurrences of those splits
              UNION
              SELECT
                 s.timestamp,
                 s.scheduled,
                 s.scenario_id,
                 s.account_id,
                 s.scaled_qty,
                 alr_next_event(s.scheduled, s.timestamp, s.post_date)
              FROM recurring_splits_and_transaction s
              WHERE s.post_date IS NOT NULL
                 AND s.post_date <= '2023-01-01'   --   MANU artificial limit

           ), splits_and_transaction AS (
              --  The recurring splits
              SELECT * FROM recurring_splits_and_transaction
              WHERE post_date IS NOT NULL

              --  The non-recurring splits
              UNION
              SELECT
                 t.timestamp,
                 t.scheduled,
                 t.scenario_id,
                 s.account_id,
                 s.scaled_qty,
                 s.post_date
              FROM alr_transactions t
                 JOIN alr_splits s ON (s.transaction_id = t.id)
              WHERE t.scheduled IS NULL
           )

           SELECT
              row_number() OVER () as id,   --  for django's sake
              alr_accounts.id AS account_id,
              alr_accounts.commodity_id,
              s.post_date as mindate,
              scenarios.id as scenario_id,
              scheduled.include as include_scheduled,
              COALESCE(
                 LEAD(s.post_date)
                    OVER (PARTITION BY alr_accounts.id,
                             scenarios.id, scheduled.include
                          ORDER by post_date),
                 {armageddon}
                ) AS maxdate,
              CAST( sum(s.scaled_qty)
                 OVER (PARTITION BY alr_accounts.id,
                             scenarios.id, scheduled.include
                       ORDER BY post_date
                       ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
                 AS FLOAT
                ) / alr_accounts.commodity_scu
                AS balance
           FROM
              splits_and_transaction s
              JOIN scenarios ON
                 (s.scenario_id = {models.Scenarios.NO_SCENARIO}
                  OR s.scenario_id = scenarios.id)
              JOIN scheduled ON
                 (s.scheduled IS NULL OR scheduled.include)
              JOIN alr_accounts ON (s.account_id = alr_accounts.id)
        ;

        --------------------
        --  Similar to balances, but instead of giving the balance as shares
        --  for stock accounts, it computes their monetary value by using the
        --  historical price of the stock at that time.
        --  Ignores scheduled transactions
        --------------------

        DROP VIEW IF EXISTS alr_balances_currency;
        CREATE VIEW alr_balances_currency AS
            SELECT
               alr_balances.id,
               alr_balances.account_id,
               alr_commodities.id as currency_id,
               alr_balances.scenario_id,
               alr_balances.include_scheduled,
               max(alr_balances.mindate, p.mindate) as mindate,
               min(alr_balances.maxdate, p.maxdate) as maxdate,
               CAST(alr_balances.balance * p.scaled_price
                    AS FLOAT)
                  / source.price_scale as balance,
               alr_balances.balance as shares,
               CAST(p.scaled_price AS FLOAT)
                  / source.price_scale
                  as computed_price
            FROM
               alr_balances,
               alr_price_history_with_turnkey p,
               alr_commodities,
               alr_commodities source
            WHERE
               --  price from: the account's commodity
               source.id = alr_balances.commodity_id
               AND alr_balances.commodity_id=p.origin_id

               --  price target: the user's requested currency
               AND p.target_id=alr_commodities.id

               --  intervals intersect
               AND alr_balances.mindate < p.maxdate
               AND p.mindate < alr_balances.maxdate

               --  target commodities can only be currencies
               AND alr_commodities.kind='C'
        ;

        ------------------
        --  Returns all splits with the associated value, scaled
        --  as needed.
        --  This includes splits from scheduled transactions, which might have
        --  to be ignored later.
        ------------------

        DROP VIEW IF EXISTS alr_splits_with_value;
        CREATE VIEW alr_splits_with_value AS
            SELECT
               row_number() OVER () as id,   --  for django's sake
               alr_splits.*,
               CAST(alr_splits.scaled_value AS FLOAT)
                  / alr_commodities.price_scale
                  AS value,
               CAST(alr_splits.scaled_value
                    * alr_accounts.commodity_scu AS FLOAT)
                  / (alr_splits.scaled_qty * alr_commodities.price_scale)
                  AS computed_price
            FROM
               alr_splits
               JOIN alr_accounts ON (alr_splits.account_id=alr_accounts.id)
               JOIN alr_commodities
                  ON (alr_splits.value_commodity_id=alr_commodities.id)
        ;

        --------------------
        --  Compute current prices
        --------------------

        DROP VIEW IF EXISTS alr_latest_price;
        CREATE VIEW alr_latest_price AS
            SELECT
               alr_prices.*
            FROM alr_prices,
               (SELECT origin_id, MAX(date) as date
                  FROM alr_prices GROUP BY origin_id) latest
            WHERE alr_prices.origin_id=latest.origin_id
              AND alr_prices.date=latest.date
        ;

        --------------------
        --  For all accounts, compute the total amount invested (i.e. money
        --  transfered from other user accounts) and realized gains (i.e.
        --  money transferred to other user accounts).
        --
        --  For efficiency (to avoid traversing tables multiple times), this
        --  duplicates the alr_balances and alr_balances_currency views.
        --
        --  To handle multi-currency, the computation is duplicated in all
        --  possible currencies known in the database, applying the exchange
        --  rate at the time of the transaction.
        --
        --  All values given in currency_id and unscaled
        --------------------

        DROP VIEW IF EXISTS alr_invested;
        CREATE VIEW alr_invested AS
           WITH internal_splits AS (
              SELECT s2.transaction_id,
                 s2.account_id,
                 xrate.target_id,
                 CAST(s2.scaled_value       --  number of shares
                      * xrate.scaled_price  --  convert to currency
                        AS FLOAT)
                    / (c2.price_scale       --  scale of scaled_value
                      * xrate.price_scale)  --  scale of xrate.scaled_price
                AS value
              FROM
                 alr_splits s2

                 --  All the splits that transfer money between two accounts
                 --  (they do not modify overall networth).
                 JOIN alr_accounts s2a ON (s2.account_id=s2a.id)
                 JOIN alr_account_kinds s2ak
                     ON (s2a.kind_id=s2ak.id
                         AND s2ak.category in ({models.AccountKindCategory.EQUITY}, {models.AccountKindCategory.LIABILITY}, {models.AccountKindCategory.ASSET}))
                 JOIN alr_commodities c2 ON (s2.value_commodity_id = c2.id)

                 --  To handle multi-currencies, we convert the prices to a
                 --  common currency
                 JOIN alr_price_history_with_turnkey xrate
                    ON (s2.value_commodity_id=xrate.origin_id
                        AND s2.post_date >= xrate.mindate
                        AND s2.post_date < xrate.maxdate)
           ),
           include_empty_range AS (
              SELECT
                 a.id AS account_id,
                 a.commodity_id,
                 s2.target_id as currency_id, --  currency for investment,..
                 s.post_date AS mindate,
                 COALESCE(
                    LEAD(s.post_date) OVER win,
                    {armageddon}
                 ) AS maxdate,
                 CAST(SUM(CASE WHEN s.account_id = s2.account_id
                               THEN s.scaled_qty ELSE 0 END)
                    OVER win
                    AS FLOAT
                   ) / a.commodity_scu
                   AS shares,
                 SUM(CASE WHEN s.account_id <> s2.account_id AND s2.value < 0
                          THEN -s2.value
                          ELSE 0 END)
                    OVER win
                    AS invested,
                 SUM(CASE WHEN s.account_id <> s2.account_id AND s2.value > 0
                          THEN s2.value
                          ELSE 0 END)
                    OVER win
                    AS realized_gain,
                 SUM(CASE WHEN s.account_id <> s2.account_id
                            AND s2.value <> 0
                            AND s.scaled_qty <> 0
                          THEN abs(s2.value)
                          ELSE 0 END)
                    OVER win
                    AS invested_for_shares,
                 CAST(SUM(CASE WHEN s.account_id <> s2.account_id
                            AND s2.value <> 0 AND s.scaled_qty <> 0
                          THEN abs(s.scaled_qty) ELSE 0 END)
                       OVER win
                      AS FLOAT)
                    / a.commodity_scu
                    AS shares_transacted
               FROM alr_splits s
                 JOIN internal_splits s2 USING (transaction_id)
                 JOIN alr_accounts a ON (s.account_id = a.id)
               WINDOW win AS (
                   PARTITION BY s.account_id, s2.target_id
                   ORDER BY s.post_date
                   ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
               )
           )
           SELECT *
             FROM include_empty_range
            WHERE mindate <> maxdate
        ;

        --------------------
        --  For all accounts, compute the return on investment at any point
        --  in time, by combining the balance at that time with the total
        --  amount invested that far and realized gains moved out of the
        --  account.
        --------------------

        DROP VIEW IF EXISTS alr_roi;
        CREATE VIEW alr_roi AS
           SELECT
              row_number() OVER () as id,   --  for django's sake
              max(b.mindate, p.mindate) as mindate,
              min(b.maxdate, p.maxdate) as maxdate,
              b.commodity_id,    --  which stock are talking about ?
              b.account_id,      --  traded in which account ?
              b.realized_gain,   --  in b.currency_id
              b.invested,        --  in b.currency_id
              b.shares,          --  in b.commodity_id
              b.currency_id,     --  all values are given in this currency
              CAST(b.shares * p.scaled_price AS FLOAT) / p.price_scale
                 AS balance,
              CAST(p.scaled_price AS FLOAT) / p.price_scale
                 AS computed_price,
              (CAST(b.shares * p.scaled_price AS FLOAT) / p.price_scale
                 + b.realized_gain) / b.invested as roi,
              CAST(b.shares * p.scaled_price AS FLOAT) / p.price_scale
                 + b.realized_gain - b.invested as pl,
              (b.invested - b.realized_gain) / b.shares as average_cost,
              (b.invested_for_shares / b.shares_transacted) as weighted_average
           FROM
              alr_invested b

              --  price of shares given in the same currency as
              --  investment, gains, ...
              JOIN alr_price_history_with_turnkey p
                 ON (b.commodity_id = p.origin_id
                     AND b.currency_id = p.target_id)
           WHERE
              --  intervals intersect
              b.mindate < p.maxdate
              AND p.mindate < b.maxdate
        ;

        --------------------
        --  Compute when scheduled transactions occur
        --------------------

        DROP VIEW IF EXISTS alr_future_transactions;
        CREATE VIEW alr_future_transactions AS
           WITH RECURSIVE nextEvents AS (
              SELECT n.id, n.timestamp, n.scheduled,
                 alr_next_event(n.scheduled, n.timestamp, n.last_occurrence) as nextdate
              FROM alr_transactions n
              WHERE n.scheduled IS NOT NULL

              UNION
              SELECT n.id, n.timestamp, n.scheduled,
                 alr_next_event(n.scheduled, n.timestamp, nextdate)
              FROM nextEvents n
              WHERE n.nextdate IS NOT NULL
           )
           SELECT
              row_number() OVER () as id,   --  for django's sake
              id as transaction_id,
              nextdate
           FROM nextEvents
           WHERE nextdate IS NOT NULL
        ;
        """
        )
    ]
